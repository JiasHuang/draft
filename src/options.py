#!/usr/bin/env python

import os
import sys
import re

import xml.etree.ElementTree as ET
from optparse import OptionParser

tab = ' ' * 4

dict_ctype = {
    'char*' : 'optarg',
    'char' : '1',
    'int' : 'strtoul(optarg, NULL, 0)',
    'unsigned int' : 'strtoul(optarg, NULL, 0)',
    'double' : 'strtod(optarg, NULL);'
}

dict_has_arg = {
    'no_argument' : '',
    'required_argument' : ':',
    'optional_argument' : '::'
}

codeText = """
/*
 * This file is automatically generated from option.py.
 * Do not edit it directly.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <getopt.h>

enum {
    @CODE_ENUM
    XOPT_HELP
};

struct xopt {
    @CODE_STRUCT
};

static struct option xopt_long_options[] = {
    @CODE_LONG_OPTIONS
    {0, 0, 0, 0}
};

#define XOPT_SHORT_OPTIONS "@CODE_SHORT_OPTIONS"

static void (*xopt_print_usage_callback_func)(void *arg) = NULL;
static void *xopt_print_usage_callback_arg = NULL;

static void xopt_install_usage_callback(void (*func)(void*), void *arg)
{
    xopt_print_usage_callback_func = func;
    xopt_print_usage_callback_arg = arg;
}

static void xopt_print_usage ()
{
    if (xopt_print_usage_callback_func)
        xopt_print_usage_callback_func(xopt_print_usage_callback_arg);
    @CODE_USAGE
}

static void xopt_parse_args(struct xopt *xopt, int argc, char **argv)
{
    int opt;

    memset(xopt, 0, sizeof(*xopt));

    @CODE_DEFAULT

    while ((opt = getopt_long (argc, argv, XOPT_SHORT_OPTIONS, xopt_long_options, NULL)) != -1) {
        switch (opt) {
            @CODE_PARSE
            case XOPT_HELP:
            default:
                xopt_print_usage();
                exit(0);
                break;
        }
    }
}

"""

class opt:
    def __init__(self, element):
        self.element = element
        self.name = element.find('name').text
        self.cname = self.name.replace('-', '_')
    def get(self, o):
        if self.element.find(o) is not None:
            return self.element.find(o).text
        else:
            return None

def enum(name):
    return 'XOPT_'+ name.upper()

def getIndent(code):
    global codeText
    m = re.search(r'([ ]*)'+re.escape(code), codeText)
    if m:
        return m.group(1)
    return None

def getShortOption(usage):
    m = re.search('^-(\w),', usage)
    if m:
        return m.group(1)
    return None

def getMaxLen(options, key):
    maxlen = 0
    for o in options:
        val = o.get(key)
        if val and len(val) > maxlen:
            maxlen = len(val)
    return maxlen

def genMaxLen(options, keys):
    maxlen = {}
    for key in keys:
        maxlen[key] = getMaxLen(options, key)
    return maxlen

def genCode_enum(options):
    lines = []
    for o in options:
        cname = o.cname
        lines.append('%s,' %(enum(cname)))
    return '\n'.join(lines)

def genCode_struct(options, maxlen):
    lines = []
    for o in options:
        cname = o.cname
        ctype = o.get('ctype')
        array = o.get('array')
        paddings = ' ' * (maxlen['ctype'] - len(ctype))
        if array:
            lines.append('%s%s %s[%s];' %(ctype, paddings, cname, array))
        else:
            lines.append('%s%s %s;' %(ctype, paddings, cname))
        paddings_cnt = ' ' * (maxlen['ctype'] - len('int'))
        lines.append('%s%s %s_cnt;' %('int', paddings_cnt, cname))
    return '\n'.join(lines)

def genCode_longOptions(options, maxlen):
    lines = []
    for o in options:
        name = o.name
        cname = o.cname
        has_arg = o.get('has_arg')
        paddings = ' ' * (maxlen['name'] - len(name) + maxlen['has_arg'] - len(has_arg))
        lines.append('{\"%s\",%s %s, 0, %s},' %(name, paddings, has_arg, enum(cname)))
    paddings_help = ' ' * (maxlen['name'] - len('help') + maxlen['has_arg'] - len('no_argument'))
    lines.append('{\"%s\",%s %s, 0, %s},' %('help', paddings_help, 'no_argument', 'XOPT_HELP'))
    return '\n'.join(lines)

def genCode_shortOptions(options):
    global dict_has_arg
    txt = ''
    for o in options:
        usage = o.get('usage')
        has_arg = o.get('has_arg')
        shortOption = getShortOption(usage)
        if shortOption:
            txt += '%s%s' %(shortOption, dict_has_arg[has_arg])
    return txt

def genCode_usage(options, maxlen):
    lines = []
    for o in options:
        usage = o.get('usage')
        desc = o.get('desc')
        default = o.get('default')
        paddings = ' ' * (maxlen['usage'] - len(usage))
        if default:
            lines.append('printf(\"\\t%s %s: %s (Default: %s)\\n\");' %(usage, paddings, desc, default))
        else:
            lines.append('printf(\"\\t%s %s: %s\\n\");' %(usage, paddings, desc))
    return '\n'.join(lines)

def genCode_parse(options):
    global tab, dict_ctype
    lines = []
    for o in options:
        cname = o.cname
        ctype = o.get('ctype')
        usage = o.get('usage')
        array = o.get('array')
        shortOption = getShortOption(usage)
        if shortOption:
            lines.append('case \'%s\':' %(shortOption))
        lines.append('case %s:' %(enum(cname)))
        if array:
            lines.append('%sif (xopt->%s_cnt < %s) xopt->%s[xopt->%s_cnt] = %s;' %(tab, cname, array, cname, cname, dict_ctype[ctype]))
        else:
            lines.append('%sxopt->%s = %s;' %(tab, cname, dict_ctype[ctype]))
        lines.append('%sxopt->%s_cnt++;' %(tab, cname))
        lines.append('%sbreak;' %(tab))
    return '\n'.join(lines)

def genCode_default(options):
    lines = []
    for o in options:
        cname = o.cname
        ctype = o.get('ctype')
        default = o.get('default')
        if default:
            if ctype == 'char*':
                lines.append('xopt->%s = (char*)"%s";' %(cname, default))
            else:
                lines.append('xopt->%s = %s;' %(cname, default))
    if len(lines) > 0:
        return '\n'.join(lines)
    return '0'

def genCode(root):

    global codeText

    options = []
    for e in root.findall('./options/option'):
        options.append(opt(e))

    maxlen = genMaxLen(options, ['name', 'ctype', 'has_arg', 'usage', 'desc', 'default'])

    enumText = genCode_enum(options).replace('\n', '\n'+getIndent('@CODE_ENUM'))
    codeText = codeText.replace('@CODE_ENUM', enumText)

    structText = genCode_struct(options, maxlen).replace('\n', '\n'+getIndent('@CODE_STRUCT'))
    codeText = codeText.replace('@CODE_STRUCT', structText)

    longOptionsText = genCode_longOptions(options, maxlen).replace('\n', '\n'+getIndent('@CODE_LONG_OPTIONS'))
    codeText = codeText.replace('@CODE_LONG_OPTIONS', longOptionsText)

    shortOptionsText = genCode_shortOptions(options)
    codeText = codeText.replace('@CODE_SHORT_OPTIONS', shortOptionsText)

    usageText = genCode_usage(options, maxlen).replace('\n', '\n'+getIndent('@CODE_USAGE'))
    codeText = codeText.replace('@CODE_USAGE', usageText)

    parseText = genCode_parse(options).replace('\n', '\n'+getIndent('@CODE_PARSE'))
    codeText = codeText.replace('@CODE_PARSE', parseText)

    defaultText = genCode_default(options).replace('\n', '\n'+getIndent('@CODE_DEFAULT'))
    codeText = codeText.replace('@CODE_DEFAULT', defaultText)

    print(codeText)
    return

def main():

    parser = OptionParser()
    parser.add_option("-i", "--input", dest="input")
    parser.add_option("-o", "--output", dest="output")
    (options, args) = parser.parse_args()

    conf = options.input or 'options.xml'
    code = options.output or 'options.h'

    if not os.path.exists(conf):
        print('Not Found : ' + conf)
        return

    tree = ET.parse(conf)
    root = tree.getroot()

    if code != '-':
        sys.stdout = open(code, "w")

    genCode(root)

    return

if __name__ == "__main__":
    main()
